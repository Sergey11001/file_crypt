{"ast":null,"code":"export async function decryptFile(encryptedBuffer, encryptedAesKey, privateKeyPem) {\n  try {\n    if (!encryptedBuffer || !encryptedAesKey || !privateKeyPem) {\n      throw new Error(\"Missing required parameters\");\n    }\n    const symmetricKey = await decryptWithPrivateKey(encryptedAesKey, privateKeyPem);\n    if (!(symmetricKey instanceof ArrayBuffer)) {\n      throw new Error(\"Symmetric key must be an ArrayBuffer\");\n    }\n    if (encryptedBuffer.byteLength < 12) {\n      throw new Error(\"Encrypted data too short to contain IV\");\n    }\n    const iv = encryptedBuffer.slice(0, 12);\n    const encryptedData = encryptedBuffer.slice(12);\n    const cryptoKey = await window.crypto.subtle.importKey(\"raw\", symmetricKey, {\n      name: \"AES-GCM\"\n    }, false, [\"decrypt\"]);\n    const decryptedData = await window.crypto.subtle.decrypt({\n      name: \"AES-GCM\",\n      iv: new Uint8Array(iv),\n      tagLength: 128\n    }, cryptoKey, encryptedData);\n    return new Blob([decryptedData]);\n  } catch (error) {\n    throw new Error(`File decryption failed: ${error.message}`);\n  }\n}\nexport async function decryptWithPrivateKey(encryptedKeyBase64, privateKeyPem) {\n  const privateKey = await importPrivateKey(privateKeyPem);\n  const encryptedKeyBuffer = base64ToArrayBuffer(encryptedKeyBase64);\n  return await window.crypto.subtle.decrypt({\n    name: \"RSA-OAEP\"\n  }, privateKey, encryptedKeyBuffer);\n}\nasync function importPrivateKey(pem) {\n  const pemHeader = \"-----BEGIN PRIVATE KEY-----\";\n  const pemFooter = \"-----END PRIVATE KEY-----\";\n  const pemContents = pem.replace(pemHeader, \"\").replace(pemFooter, \"\").replace(/\\s+/g, \"\");\n  const binaryDer = base64ToArrayBuffer(pemContents);\n  return await window.crypto.subtle.importKey(\"pkcs8\", binaryDer, {\n    name: \"RSA-OAEP\",\n    hash: \"SHA-256\"\n  }, true, [\"decrypt\"]);\n}\nexport async function generateKeyPair() {\n  return await window.crypto.subtle.generateKey({\n    name: \"RSA-OAEP\",\n    modulusLength: 2048,\n    publicExponent: new Uint8Array([0x01, 0x00, 0x01]),\n    hash: \"SHA-256\"\n  }, true, [\"encrypt\", \"decrypt\"]);\n}\nexport async function exportPublicKey(publicKey) {\n  const exported = await window.crypto.subtle.exportKey(\"spki\", publicKey);\n  return arrayBufferToBase64(exported);\n}\nexport async function exportPrivateKey(privateKey) {\n  const exported = await window.crypto.subtle.exportKey(\"pkcs8\", privateKey);\n  const base64 = arrayBufferToBase64(exported);\n  return `-----BEGIN PRIVATE KEY-----\\n${base64}\\n-----END PRIVATE KEY-----`;\n}\nexport async function generateAesKey() {\n  return await window.crypto.subtle.generateKey({\n    name: \"AES-GCM\",\n    length: 256\n  }, true, [\"encrypt\", \"decrypt\"]);\n}\nexport async function encryptFile(file, key) {\n  const fileData = await file.arrayBuffer();\n  const iv = window.crypto.getRandomValues(new Uint8Array(12));\n  const encryptedData = await window.crypto.subtle.encrypt({\n    name: \"AES-GCM\",\n    iv: iv\n  }, key, fileData);\n\n  // Объединяем IV и зашифрованные данные\n  const result = new Uint8Array(iv.length + encryptedData.byteLength);\n  result.set(iv, 0);\n  result.set(new Uint8Array(encryptedData), iv.length);\n  return new Blob([result], {\n    type: file.type\n  });\n}\nexport async function encryptWithPublicKey(data, publicKeyPem) {\n  try {\n    if (data instanceof CryptoKey) {\n      if (!data.extractable) {\n        throw new Error(\"Key is not extractable\");\n      }\n      const exportedKey = await window.crypto.subtle.exportKey(\"raw\", data);\n      const publicKey = await importPublicKey(publicKeyPem);\n      const encrypted = await window.crypto.subtle.encrypt({\n        name: \"RSA-OAEP\"\n      }, publicKey, exportedKey);\n      return arrayBufferToBase64(encrypted);\n    } else {\n      const publicKey = await importPublicKey(publicKeyPem);\n      const encrypted = await window.crypto.subtle.encrypt({\n        name: \"RSA-OAEP\"\n      }, publicKey, data);\n      return arrayBufferToBase64(encrypted);\n    }\n  } catch (error) {\n    console.error(\"Encryption error:\", error);\n    throw new Error(\"Failed to encrypt with public key\");\n  }\n}\nasync function importPublicKey(pem) {\n  // Удаляем PEM заголовки\n  const pemHeader = \"-----BEGIN PUBLIC KEY-----\";\n  const pemFooter = \"-----END PUBLIC KEY-----\";\n  const pemContents = pem.replace(pemHeader, '').replace(pemFooter, '').replace(/\\s+/g, '');\n\n  // Декодируем Base64\n  const binaryDer = base64ToArrayBuffer(pemContents);\n  return await window.crypto.subtle.importKey(\"spki\", binaryDer, {\n    name: \"RSA-OAEP\",\n    hash: \"SHA-256\"\n  }, true, [\"encrypt\"]);\n}\nfunction arrayBufferToBase64(buffer) {\n  let binary = '';\n  const bytes = new Uint8Array(buffer);\n  for (let i = 0; i < bytes.byteLength; i++) {\n    binary += String.fromCharCode(bytes[i]);\n  }\n  return window.btoa(binary);\n}\nfunction base64ToArrayBuffer(base64) {\n  const binaryString = window.atob(base64);\n  const bytes = new Uint8Array(binaryString.length);\n  for (let i = 0; i < binaryString.length; i++) {\n    bytes[i] = binaryString.charCodeAt(i);\n  }\n  return bytes;\n}","map":{"version":3,"names":["decryptFile","encryptedBuffer","encryptedAesKey","privateKeyPem","Error","symmetricKey","decryptWithPrivateKey","ArrayBuffer","byteLength","iv","slice","encryptedData","cryptoKey","window","crypto","subtle","importKey","name","decryptedData","decrypt","Uint8Array","tagLength","Blob","error","message","encryptedKeyBase64","privateKey","importPrivateKey","encryptedKeyBuffer","base64ToArrayBuffer","pem","pemHeader","pemFooter","pemContents","replace","binaryDer","hash","generateKeyPair","generateKey","modulusLength","publicExponent","exportPublicKey","publicKey","exported","exportKey","arrayBufferToBase64","exportPrivateKey","base64","generateAesKey","length","encryptFile","file","key","fileData","arrayBuffer","getRandomValues","encrypt","result","set","type","encryptWithPublicKey","data","publicKeyPem","CryptoKey","extractable","exportedKey","importPublicKey","encrypted","console","buffer","binary","bytes","i","String","fromCharCode","btoa","binaryString","atob","charCodeAt"],"sources":["/home/sergey/WebstormProjects/univer/filecrypt/src/utils/crypto.js"],"sourcesContent":["export async function decryptFile(encryptedBuffer: ArrayBuffer, encryptedAesKey: string, privateKeyPem: string): Promise<Blob> {\n    try {\n        if (!encryptedBuffer || !encryptedAesKey || !privateKeyPem) {\n            throw new Error(\"Missing required parameters\");\n        }\n\n        const symmetricKey = await decryptWithPrivateKey(encryptedAesKey, privateKeyPem);\n        if (!(symmetricKey instanceof ArrayBuffer)) {\n            throw new Error(\"Symmetric key must be an ArrayBuffer\");\n        }\n\n        if (encryptedBuffer.byteLength < 12) {\n            throw new Error(\"Encrypted data too short to contain IV\");\n        }\n\n        const iv = encryptedBuffer.slice(0, 12);\n        const encryptedData = encryptedBuffer.slice(12);\n\n        const cryptoKey = await window.crypto.subtle.importKey(\n            \"raw\",\n            symmetricKey,\n            { name: \"AES-GCM\" },\n            false,\n            [\"decrypt\"]\n        );\n\n        const decryptedData = await window.crypto.subtle.decrypt(\n            {\n                name: \"AES-GCM\",\n                iv: new Uint8Array(iv),\n                tagLength: 128\n            },\n            cryptoKey,\n            encryptedData\n        );\n\n        return new Blob([decryptedData]);\n\n    } catch (error) {\n        throw new Error(`File decryption failed: ${error.message}`);\n    }\n}\nexport async function decryptWithPrivateKey(encryptedKeyBase64, privateKeyPem) {\n    const privateKey = await importPrivateKey(privateKeyPem);\n\n    const encryptedKeyBuffer = base64ToArrayBuffer(encryptedKeyBase64);\n\n    return await window.crypto.subtle.decrypt(\n        {name: \"RSA-OAEP\"},\n        privateKey,\n        encryptedKeyBuffer\n    );\n}\n\nasync function importPrivateKey(pem) {\n    const pemHeader = \"-----BEGIN PRIVATE KEY-----\";\n    const pemFooter = \"-----END PRIVATE KEY-----\";\n    const pemContents = pem.replace(pemHeader, \"\").replace(pemFooter, \"\").replace(/\\s+/g, \"\");\n\n    const binaryDer = base64ToArrayBuffer(pemContents);\n\n    return await window.crypto.subtle.importKey(\n        \"pkcs8\",\n        binaryDer,\n        { name: \"RSA-OAEP\", hash: \"SHA-256\" },\n        true,\n        [\"decrypt\"]\n    );\n}\n\nexport async function generateKeyPair() {\n    return await window.crypto.subtle.generateKey(\n        {\n            name: \"RSA-OAEP\",\n            modulusLength: 2048,\n            publicExponent: new Uint8Array([0x01, 0x00, 0x01]),\n            hash: \"SHA-256\",\n        },\n        true,\n        [\"encrypt\", \"decrypt\"]\n    );\n}\n\nexport async function exportPublicKey(publicKey: CryptoKey) {\n    const exported = await window.crypto.subtle.exportKey(\"spki\", publicKey);\n    return arrayBufferToBase64(exported);\n}\n\nexport async function exportPrivateKey(privateKey: CryptoKey) {\n    const exported = await window.crypto.subtle.exportKey(\"pkcs8\", privateKey);\n    const base64 = arrayBufferToBase64(exported);\n    return `-----BEGIN PRIVATE KEY-----\\n${base64}\\n-----END PRIVATE KEY-----`;\n}\n\nexport async function generateAesKey() {\n    return await window.crypto.subtle.generateKey(\n        {\n            name: \"AES-GCM\",\n            length: 256,\n        },\n        true,\n        [\"encrypt\", \"decrypt\"]\n    );\n}\n\nexport async function encryptFile(file, key) {\n    const fileData = await file.arrayBuffer();\n    const iv = window.crypto.getRandomValues(new Uint8Array(12));\n\n    const encryptedData = await window.crypto.subtle.encrypt(\n        {\n            name: \"AES-GCM\",\n            iv: iv\n        },\n        key,\n        fileData\n    );\n\n    // Объединяем IV и зашифрованные данные\n    const result = new Uint8Array(iv.length + encryptedData.byteLength);\n    result.set(iv, 0);\n    result.set(new Uint8Array(encryptedData), iv.length);\n\n    return new Blob([result], { type: file.type });\n}\n\nexport async function encryptWithPublicKey(data, publicKeyPem) {\n    try {\n        if (data instanceof CryptoKey) {\n            if (!data.extractable) {\n                throw new Error(\"Key is not extractable\");\n            }\n\n            const exportedKey = await window.crypto.subtle.exportKey(\"raw\", data);\n            const publicKey = await importPublicKey(publicKeyPem);\n\n            const encrypted = await window.crypto.subtle.encrypt(\n                { name: \"RSA-OAEP\" },\n                publicKey,\n                exportedKey\n            );\n\n            return arrayBufferToBase64(encrypted);\n        } else {\n            const publicKey = await importPublicKey(publicKeyPem);\n\n            const encrypted = await window.crypto.subtle.encrypt(\n                { name: \"RSA-OAEP\" },\n                publicKey,\n                data\n            );\n\n            return arrayBufferToBase64(encrypted);\n        }\n    } catch (error) {\n        console.error(\"Encryption error:\", error);\n        throw new Error(\"Failed to encrypt with public key\");\n    }\n}\n\nasync function importPublicKey(pem) {\n    // Удаляем PEM заголовки\n    const pemHeader = \"-----BEGIN PUBLIC KEY-----\";\n    const pemFooter = \"-----END PUBLIC KEY-----\";\n    const pemContents = pem\n        .replace(pemHeader, '')\n        .replace(pemFooter, '')\n        .replace(/\\s+/g, '');\n\n    // Декодируем Base64\n    const binaryDer = base64ToArrayBuffer(pemContents);\n\n    return await window.crypto.subtle.importKey(\n        \"spki\",\n        binaryDer,\n        { name: \"RSA-OAEP\", hash: \"SHA-256\" },\n        true,\n        [\"encrypt\"]\n    );\n}\n\nfunction arrayBufferToBase64(buffer) {\n    let binary = '';\n    const bytes = new Uint8Array(buffer);\n    for (let i = 0; i < bytes.byteLength; i++) {\n        binary += String.fromCharCode(bytes[i]);\n    }\n    return window.btoa(binary);\n}\n\nfunction base64ToArrayBuffer(base64) {\n    const binaryString = window.atob(base64);\n    const bytes = new Uint8Array(binaryString.length);\n    for (let i = 0; i < binaryString.length; i++) {\n        bytes[i] = binaryString.charCodeAt(i);\n    }\n    return bytes;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}