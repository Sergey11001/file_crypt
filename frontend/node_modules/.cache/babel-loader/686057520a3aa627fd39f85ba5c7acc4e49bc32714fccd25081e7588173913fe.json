{"ast":null,"code":"export async function generateAesKey() {\n  return await window.crypto.subtle.generateKey({\n    name: \"AES-GCM\",\n    length: 256\n  }, true, [\"encrypt\", \"decrypt\"]);\n}\nexport async function encryptFile(file, key) {\n  const fileData = await file.arrayBuffer();\n  const iv = window.crypto.getRandomValues(new Uint8Array(12));\n  const encryptedData = await window.crypto.subtle.encrypt({\n    name: \"AES-GCM\",\n    iv: iv\n  }, key, fileData);\n\n  // Объединяем IV и зашифрованные данные\n  const result = new Uint8Array(iv.length + encryptedData.byteLength);\n  result.set(iv, 0);\n  result.set(new Uint8Array(encryptedData), iv.length);\n  return new Blob([result], {\n    type: file.type\n  });\n}\nexport async function encryptWithPublicKey(data, publicKeyPem) {\n  // Импорт публичного ключа из PEM формата\n  const publicKey = await importPublicKey(publicKeyPem);\n\n  // Экспорт AES ключа\n  const exportedKey = await window.crypto.subtle.exportKey(\"raw\", data);\n\n  // Шифрование\n  const encrypted = await window.crypto.subtle.encrypt({\n    name: \"RSA-OAEP\"\n  }, publicKey, exportedKey);\n\n  // Конвертация в Base64\n  return arrayBufferToBase64(encrypted);\n}\nasync function importPublicKey(pem) {\n  // Удаляем PEM заголовки\n  const pemHeader = \"-----BEGIN PUBLIC KEY-----\";\n  const pemFooter = \"-----END PUBLIC KEY-----\";\n  const pemContents = pem.replace(pemHeader, '').replace(pemFooter, '').replace(/\\s+/g, '');\n\n  // Декодируем Base64\n  const binaryDer = base64ToArrayBuffer(pemContents);\n  return await window.crypto.subtle.importKey(\"spki\", binaryDer, {\n    name: \"RSA-OAEP\",\n    hash: \"SHA-256\"\n  }, true, [\"encrypt\"]);\n}\nfunction arrayBufferToBase64(buffer) {\n  let binary = '';\n  const bytes = new Uint8Array(buffer);\n  for (let i = 0; i < bytes.byteLength; i++) {\n    binary += String.fromCharCode(bytes[i]);\n  }\n  return window.btoa(binary);\n}\nfunction base64ToArrayBuffer(base64) {\n  const binaryString = window.atob(base64);\n  const bytes = new Uint8Array(binaryString.length);\n  for (let i = 0; i < binaryString.length; i++) {\n    bytes[i] = binaryString.charCodeAt(i);\n  }\n  return bytes;\n}","map":{"version":3,"names":["generateAesKey","window","crypto","subtle","generateKey","name","length","encryptFile","file","key","fileData","arrayBuffer","iv","getRandomValues","Uint8Array","encryptedData","encrypt","result","byteLength","set","Blob","type","encryptWithPublicKey","data","publicKeyPem","publicKey","importPublicKey","exportedKey","exportKey","encrypted","arrayBufferToBase64","pem","pemHeader","pemFooter","pemContents","replace","binaryDer","base64ToArrayBuffer","importKey","hash","buffer","binary","bytes","i","String","fromCharCode","btoa","base64","binaryString","atob","charCodeAt"],"sources":["/home/sergey/WebstormProjects/univer/filecrypt/src/utils/crypto.js"],"sourcesContent":["export async function generateAesKey() {\n    return await window.crypto.subtle.generateKey(\n        {\n            name: \"AES-GCM\",\n            length: 256,\n        },\n        true,\n        [\"encrypt\", \"decrypt\"]\n    );\n}\n\nexport async function encryptFile(file, key) {\n    const fileData = await file.arrayBuffer();\n    const iv = window.crypto.getRandomValues(new Uint8Array(12));\n\n    const encryptedData = await window.crypto.subtle.encrypt(\n        {\n            name: \"AES-GCM\",\n            iv: iv\n        },\n        key,\n        fileData\n    );\n\n    // Объединяем IV и зашифрованные данные\n    const result = new Uint8Array(iv.length + encryptedData.byteLength);\n    result.set(iv, 0);\n    result.set(new Uint8Array(encryptedData), iv.length);\n\n    return new Blob([result], { type: file.type });\n}\n\nexport async function encryptWithPublicKey(data, publicKeyPem) {\n    // Импорт публичного ключа из PEM формата\n    const publicKey = await importPublicKey(publicKeyPem);\n\n    // Экспорт AES ключа\n    const exportedKey = await window.crypto.subtle.exportKey(\"raw\", data);\n\n    // Шифрование\n    const encrypted = await window.crypto.subtle.encrypt(\n        { name: \"RSA-OAEP\" },\n        publicKey,\n        exportedKey\n    );\n\n    // Конвертация в Base64\n    return arrayBufferToBase64(encrypted);\n}\n\nasync function importPublicKey(pem) {\n    // Удаляем PEM заголовки\n    const pemHeader = \"-----BEGIN PUBLIC KEY-----\";\n    const pemFooter = \"-----END PUBLIC KEY-----\";\n    const pemContents = pem\n        .replace(pemHeader, '')\n        .replace(pemFooter, '')\n        .replace(/\\s+/g, '');\n\n    // Декодируем Base64\n    const binaryDer = base64ToArrayBuffer(pemContents);\n\n    return await window.crypto.subtle.importKey(\n        \"spki\",\n        binaryDer,\n        { name: \"RSA-OAEP\", hash: \"SHA-256\" },\n        true,\n        [\"encrypt\"]\n    );\n}\n\nfunction arrayBufferToBase64(buffer) {\n    let binary = '';\n    const bytes = new Uint8Array(buffer);\n    for (let i = 0; i < bytes.byteLength; i++) {\n        binary += String.fromCharCode(bytes[i]);\n    }\n    return window.btoa(binary);\n}\n\nfunction base64ToArrayBuffer(base64) {\n    const binaryString = window.atob(base64);\n    const bytes = new Uint8Array(binaryString.length);\n    for (let i = 0; i < binaryString.length; i++) {\n        bytes[i] = binaryString.charCodeAt(i);\n    }\n    return bytes;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}