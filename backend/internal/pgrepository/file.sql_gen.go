// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: file.sql

package pgrepository

import (
	"context"

	"github.com/google/uuid"
)

const availableFiles = `-- name: AvailableFiles :many
SELECT files.uuid, files.user_uuid, files.name, files.size, files.is_crypt, files.created_at,
       file_crypto_keys.symmetric_key
FROM files
         JOIN file_crypto_keys ON files.uuid = file_crypto_keys.file_uuid
WHERE file_crypto_keys.user_uuid = $1 AND files.user_uuid != file_crypto_keys.user_uuid
`

type AvailableFilesParams struct {
	UserUuid uuid.UUID `json:"user_uuid"`
}

type AvailableFilesRow struct {
	File         File   `json:"file"`
	SymmetricKey string `json:"symmetric_key"`
}

func (q *Queries) AvailableFiles(ctx context.Context, arg AvailableFilesParams) ([]AvailableFilesRow, error) {
	rows, err := q.db.Query(ctx, availableFiles, arg.UserUuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AvailableFilesRow
	for rows.Next() {
		var i AvailableFilesRow
		if err := rows.Scan(
			&i.File.Uuid,
			&i.File.UserUuid,
			&i.File.Name,
			&i.File.Size,
			&i.File.IsCrypt,
			&i.File.CreatedAt,
			&i.SymmetricKey,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const commonFile = `-- name: CommonFile :one
SELECT files.uuid, files.user_uuid, files.name, files.size, files.is_crypt, files.created_at,
       file_crypto_keys.symmetric_key
FROM files
         LEFT JOIN file_crypto_keys ON files.uuid = file_crypto_keys.file_uuid
WHERE file_crypto_keys.user_uuid IS NULL AND files.uuid = $1
`

type CommonFileParams struct {
	Uuid uuid.UUID `json:"uuid"`
}

type CommonFileRow struct {
	File         File    `json:"file"`
	SymmetricKey *string `json:"symmetric_key"`
}

func (q *Queries) CommonFile(ctx context.Context, arg CommonFileParams) (CommonFileRow, error) {
	row := q.db.QueryRow(ctx, commonFile, arg.Uuid)
	var i CommonFileRow
	err := row.Scan(
		&i.File.Uuid,
		&i.File.UserUuid,
		&i.File.Name,
		&i.File.Size,
		&i.File.IsCrypt,
		&i.File.CreatedAt,
		&i.SymmetricKey,
	)
	return i, err
}

const createFile = `-- name: CreateFile :one
INSERT INTO files (uuid, user_uuid, name, size, is_crypt)
VALUES ($1, $2, $3, $4, $5)
RETURNING uuid, user_uuid, name, size, is_crypt, created_at
`

type CreateFileParams struct {
	Uuid     uuid.UUID `json:"uuid"`
	UserUuid uuid.UUID `json:"user_uuid"`
	Name     string    `json:"name"`
	Size     int64     `json:"size"`
	IsCrypt  bool      `json:"is_crypt"`
}

func (q *Queries) CreateFile(ctx context.Context, arg CreateFileParams) (File, error) {
	row := q.db.QueryRow(ctx, createFile,
		arg.Uuid,
		arg.UserUuid,
		arg.Name,
		arg.Size,
		arg.IsCrypt,
	)
	var i File
	err := row.Scan(
		&i.Uuid,
		&i.UserUuid,
		&i.Name,
		&i.Size,
		&i.IsCrypt,
		&i.CreatedAt,
	)
	return i, err
}

const deleteAllUserFiles = `-- name: DeleteAllUserFiles :many
DELETE FROM files
WHERE user_uuid = $1
RETURNING files.uuid
`

type DeleteAllUserFilesParams struct {
	UserUuid uuid.UUID `json:"user_uuid"`
}

func (q *Queries) DeleteAllUserFiles(ctx context.Context, arg DeleteAllUserFilesParams) ([]uuid.UUID, error) {
	rows, err := q.db.Query(ctx, deleteAllUserFiles, arg.UserUuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []uuid.UUID
	for rows.Next() {
		var uuid uuid.UUID
		if err := rows.Scan(&uuid); err != nil {
			return nil, err
		}
		items = append(items, uuid)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deleteFile = `-- name: DeleteFile :exec
DELETE FROM files
WHERE user_uuid = $1 AND uuid = $2
`

type DeleteFileParams struct {
	UserUuid uuid.UUID `json:"user_uuid"`
	Uuid     uuid.UUID `json:"uuid"`
}

func (q *Queries) DeleteFile(ctx context.Context, arg DeleteFileParams) error {
	_, err := q.db.Exec(ctx, deleteFile, arg.UserUuid, arg.Uuid)
	return err
}

const file = `-- name: File :one
SELECT files.uuid, files.user_uuid, files.name, files.size, files.is_crypt, files.created_at,
       file_crypto_keys.symmetric_key
FROM files
LEFT JOIN file_crypto_keys ON files.uuid = file_crypto_keys.file_uuid
WHERE file_crypto_keys.user_uuid = $1 AND files.uuid = $2
`

type FileParams struct {
	UserUuid uuid.UUID `json:"user_uuid"`
	Uuid     uuid.UUID `json:"uuid"`
}

type FileRow struct {
	File         File    `json:"file"`
	SymmetricKey *string `json:"symmetric_key"`
}

func (q *Queries) File(ctx context.Context, arg FileParams) (FileRow, error) {
	row := q.db.QueryRow(ctx, file, arg.UserUuid, arg.Uuid)
	var i FileRow
	err := row.Scan(
		&i.File.Uuid,
		&i.File.UserUuid,
		&i.File.Name,
		&i.File.Size,
		&i.File.IsCrypt,
		&i.File.CreatedAt,
		&i.SymmetricKey,
	)
	return i, err
}

const fileByUUID = `-- name: FileByUUID :one
SELECT uuid, user_uuid, name, size, is_crypt, created_at
FROM files
WHERE files.uuid = $1
`

type FileByUUIDParams struct {
	Uuid uuid.UUID `json:"uuid"`
}

func (q *Queries) FileByUUID(ctx context.Context, arg FileByUUIDParams) (File, error) {
	row := q.db.QueryRow(ctx, fileByUUID, arg.Uuid)
	var i File
	err := row.Scan(
		&i.Uuid,
		&i.UserUuid,
		&i.Name,
		&i.Size,
		&i.IsCrypt,
		&i.CreatedAt,
	)
	return i, err
}

const files = `-- name: Files :many
SELECT files.uuid, files.user_uuid, files.name, files.size, files.is_crypt, files.created_at,
       file_crypto_keys.symmetric_key
FROM files
LEFT JOIN file_crypto_keys ON files.uuid = file_crypto_keys.file_uuid AND files.user_uuid = file_crypto_keys.user_uuid
WHERE files.user_uuid = $1
`

type FilesParams struct {
	UserUuid uuid.UUID `json:"user_uuid"`
}

type FilesRow struct {
	File         File    `json:"file"`
	SymmetricKey *string `json:"symmetric_key"`
}

func (q *Queries) Files(ctx context.Context, arg FilesParams) ([]FilesRow, error) {
	rows, err := q.db.Query(ctx, files, arg.UserUuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FilesRow
	for rows.Next() {
		var i FilesRow
		if err := rows.Scan(
			&i.File.Uuid,
			&i.File.UserUuid,
			&i.File.Name,
			&i.File.Size,
			&i.File.IsCrypt,
			&i.File.CreatedAt,
			&i.SymmetricKey,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
