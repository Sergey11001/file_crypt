// Package openapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.3.0 DO NOT EDIT.
package openapi

import (
	"fmt"
	"net/http"

	externalRef0 "univer/internal/dto"
	externalRef1 "univer/pkg/lib/httpapi"

	"github.com/go-chi/chi/v5"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// AvailableFilesResult defines model for AvailableFilesResult.
type AvailableFilesResult struct {
	Files []externalRef0.File `json:"files"`
}

// CreateFileResult defines model for CreateFileResult.
type CreateFileResult struct {
	File externalRef0.File `json:"file"`
}

// ErrorResult defines model for ErrorResult.
type ErrorResult = externalRef1.ErrorResult

// FilesResult defines model for FilesResult.
type FilesResult struct {
	Files []externalRef0.File `json:"files"`
}

// RefreshResult defines model for RefreshResult.
type RefreshResult struct {
	AccessToken  string `json:"access_token"`
	RefreshToken string `json:"refresh_token"`
}

// SignInResult defines model for SignInResult.
type SignInResult struct {
	AccessToken  string `json:"access_token"`
	Email        string `json:"email"`
	PublicKey    string `json:"public_key"`
	RefreshToken string `json:"refresh_token"`
}

// SignUpResult defines model for SignUpResult.
type SignUpResult struct {
	AccessToken  string `json:"access_token"`
	PublicKey    string `json:"public_key"`
	RefreshToken string `json:"refresh_token"`
}

// UsersResult defines model for UsersResult.
type UsersResult struct {
	Users []externalRef0.User `json:"users"`
}

// DeleteFileAccessInput defines model for DeleteFileAccessInput.
type DeleteFileAccessInput struct {
	RecipientUuid openapi_types.UUID `json:"recipient_uuid"`
}

// RefreshInput defines model for RefreshInput.
type RefreshInput struct {
	Token string `json:"token"`
}

// ShareFileInput defines model for ShareFileInput.
type ShareFileInput struct {
	RecipientUuid openapi_types.UUID `json:"recipient_uuid"`
	SymmetricKey  string             `json:"symmetric_key"`
}

// SignInInput defines model for SignInInput.
type SignInInput struct {
	Email    string `json:"email"`
	Password string `json:"password"`
}

// SignUpInput defines model for SignUpInput.
type SignUpInput struct {
	Email     string `json:"email"`
	Name      string `json:"name"`
	Password  string `json:"password"`
	PublicKey string `json:"public_key"`
}

// UpdateUserKeysInput defines model for UpdateUserKeysInput.
type UpdateUserKeysInput struct {
	PublicKey string `json:"public_key"`
}

// CreateFileMultipartBody defines parameters for CreateFile.
type CreateFileMultipartBody struct {
	File         openapi_types.File `json:"file"`
	Name         string             `json:"name"`
	SymmetricKey string             `json:"symmetric_key"`
}

// DeleteFileAccessJSONBody defines parameters for DeleteFileAccess.
type DeleteFileAccessJSONBody struct {
	RecipientUuid openapi_types.UUID `json:"recipient_uuid"`
}

// ShareFileJSONBody defines parameters for ShareFile.
type ShareFileJSONBody struct {
	RecipientUuid openapi_types.UUID `json:"recipient_uuid"`
	SymmetricKey  string             `json:"symmetric_key"`
}

// RefreshJSONBody defines parameters for Refresh.
type RefreshJSONBody struct {
	Token string `json:"token"`
}

// SignInJSONBody defines parameters for SignIn.
type SignInJSONBody struct {
	Email    string `json:"email"`
	Password string `json:"password"`
}

// SignUpJSONBody defines parameters for SignUp.
type SignUpJSONBody struct {
	Email     string `json:"email"`
	Name      string `json:"name"`
	Password  string `json:"password"`
	PublicKey string `json:"public_key"`
}

// UpdateUserKeysJSONBody defines parameters for UpdateUserKeys.
type UpdateUserKeysJSONBody struct {
	PublicKey string `json:"public_key"`
}

// CreateFileMultipartRequestBody defines body for CreateFile for multipart/form-data ContentType.
type CreateFileMultipartRequestBody CreateFileMultipartBody

// DeleteFileAccessJSONRequestBody defines body for DeleteFileAccess for application/json ContentType.
type DeleteFileAccessJSONRequestBody DeleteFileAccessJSONBody

// ShareFileJSONRequestBody defines body for ShareFile for application/json ContentType.
type ShareFileJSONRequestBody ShareFileJSONBody

// RefreshJSONRequestBody defines body for Refresh for application/json ContentType.
type RefreshJSONRequestBody RefreshJSONBody

// SignInJSONRequestBody defines body for SignIn for application/json ContentType.
type SignInJSONRequestBody SignInJSONBody

// SignUpJSONRequestBody defines body for SignUp for application/json ContentType.
type SignUpJSONRequestBody SignUpJSONBody

// UpdateUserKeysJSONRequestBody defines body for UpdateUserKeys for application/json ContentType.
type UpdateUserKeysJSONRequestBody UpdateUserKeysJSONBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// AvailableFiles
	// (GET /available-files)
	AvailableFiles(w http.ResponseWriter, r *http.Request)
	// DownloadCommonFile
	// (POST /download/common/files/{uuid})
	DownloadCommonFile(w http.ResponseWriter, r *http.Request, uuid openapi_types.UUID)
	// DownloadFile
	// (POST /download/files/{uuid})
	DownloadFile(w http.ResponseWriter, r *http.Request, uuid openapi_types.UUID)
	// CreateFile
	// (POST /file)
	CreateFile(w http.ResponseWriter, r *http.Request)
	// DeleteFileAccess
	// (POST /file/{uuid}/access)
	DeleteFileAccess(w http.ResponseWriter, r *http.Request, uuid openapi_types.UUID)
	// Files
	// (GET /files)
	Files(w http.ResponseWriter, r *http.Request)
	// DeleteFile
	// (DELETE /files/{uuid})
	DeleteFile(w http.ResponseWriter, r *http.Request, uuid openapi_types.UUID)
	// ShareFile
	// (POST /files/{uuid})
	ShareFile(w http.ResponseWriter, r *http.Request, uuid openapi_types.UUID)
	// Refresh
	// (POST /refresh)
	Refresh(w http.ResponseWriter, r *http.Request)
	// SignIn
	// (POST /sign-in)
	SignIn(w http.ResponseWriter, r *http.Request)
	// SignUp
	// (POST /sign-up)
	SignUp(w http.ResponseWriter, r *http.Request)
	// Users
	// (GET /users)
	Users(w http.ResponseWriter, r *http.Request)
	// AvailableUsers
	// (GET /users/available/{uuid})
	AvailableUsers(w http.ResponseWriter, r *http.Request, uuid openapi_types.UUID)
	// UsersForShare
	// (GET /users/for-share/{uuid})
	UsersForShare(w http.ResponseWriter, r *http.Request, uuid openapi_types.UUID)
	// UpdateUserKeys
	// (POST /users/update-keys)
	UpdateUserKeys(w http.ResponseWriter, r *http.Request)
}

// Unimplemented server implementation that returns http.StatusNotImplemented for each endpoint.

type Unimplemented struct{}

// AvailableFiles
// (GET /available-files)
func (_ Unimplemented) AvailableFiles(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// DownloadCommonFile
// (POST /download/common/files/{uuid})
func (_ Unimplemented) DownloadCommonFile(w http.ResponseWriter, r *http.Request, uuid openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// DownloadFile
// (POST /download/files/{uuid})
func (_ Unimplemented) DownloadFile(w http.ResponseWriter, r *http.Request, uuid openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// CreateFile
// (POST /file)
func (_ Unimplemented) CreateFile(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// DeleteFileAccess
// (POST /file/{uuid}/access)
func (_ Unimplemented) DeleteFileAccess(w http.ResponseWriter, r *http.Request, uuid openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Files
// (GET /files)
func (_ Unimplemented) Files(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// DeleteFile
// (DELETE /files/{uuid})
func (_ Unimplemented) DeleteFile(w http.ResponseWriter, r *http.Request, uuid openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// ShareFile
// (POST /files/{uuid})
func (_ Unimplemented) ShareFile(w http.ResponseWriter, r *http.Request, uuid openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Refresh
// (POST /refresh)
func (_ Unimplemented) Refresh(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// SignIn
// (POST /sign-in)
func (_ Unimplemented) SignIn(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// SignUp
// (POST /sign-up)
func (_ Unimplemented) SignUp(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Users
// (GET /users)
func (_ Unimplemented) Users(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// AvailableUsers
// (GET /users/available/{uuid})
func (_ Unimplemented) AvailableUsers(w http.ResponseWriter, r *http.Request, uuid openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// UsersForShare
// (GET /users/for-share/{uuid})
func (_ Unimplemented) UsersForShare(w http.ResponseWriter, r *http.Request, uuid openapi_types.UUID) {
	w.WriteHeader(http.StatusNotImplemented)
}

// UpdateUserKeys
// (POST /users/update-keys)
func (_ Unimplemented) UpdateUserKeys(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// AvailableFiles operation middleware
func (siw *ServerInterfaceWrapper) AvailableFiles(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AvailableFiles(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DownloadCommonFile operation middleware
func (siw *ServerInterfaceWrapper) DownloadCommonFile(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "uuid", chi.URLParam(r, "uuid"), &uuid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "uuid", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DownloadCommonFile(w, r, uuid)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DownloadFile operation middleware
func (siw *ServerInterfaceWrapper) DownloadFile(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "uuid", chi.URLParam(r, "uuid"), &uuid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "uuid", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DownloadFile(w, r, uuid)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// CreateFile operation middleware
func (siw *ServerInterfaceWrapper) CreateFile(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateFile(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DeleteFileAccess operation middleware
func (siw *ServerInterfaceWrapper) DeleteFileAccess(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "uuid", chi.URLParam(r, "uuid"), &uuid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "uuid", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteFileAccess(w, r, uuid)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// Files operation middleware
func (siw *ServerInterfaceWrapper) Files(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Files(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DeleteFile operation middleware
func (siw *ServerInterfaceWrapper) DeleteFile(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "uuid", chi.URLParam(r, "uuid"), &uuid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "uuid", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteFile(w, r, uuid)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ShareFile operation middleware
func (siw *ServerInterfaceWrapper) ShareFile(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "uuid", chi.URLParam(r, "uuid"), &uuid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "uuid", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ShareFile(w, r, uuid)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// Refresh operation middleware
func (siw *ServerInterfaceWrapper) Refresh(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Refresh(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// SignIn operation middleware
func (siw *ServerInterfaceWrapper) SignIn(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SignIn(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// SignUp operation middleware
func (siw *ServerInterfaceWrapper) SignUp(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SignUp(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// Users operation middleware
func (siw *ServerInterfaceWrapper) Users(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Users(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// AvailableUsers operation middleware
func (siw *ServerInterfaceWrapper) AvailableUsers(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "uuid", chi.URLParam(r, "uuid"), &uuid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "uuid", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AvailableUsers(w, r, uuid)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// UsersForShare operation middleware
func (siw *ServerInterfaceWrapper) UsersForShare(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "uuid" -------------
	var uuid openapi_types.UUID

	err = runtime.BindStyledParameterWithOptions("simple", "uuid", chi.URLParam(r, "uuid"), &uuid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "uuid", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UsersForShare(w, r, uuid)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// UpdateUserKeys operation middleware
func (siw *ServerInterfaceWrapper) UpdateUserKeys(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateUserKeys(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/available-files", wrapper.AvailableFiles)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/download/common/files/{uuid}", wrapper.DownloadCommonFile)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/download/files/{uuid}", wrapper.DownloadFile)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/file", wrapper.CreateFile)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/file/{uuid}/access", wrapper.DeleteFileAccess)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/files", wrapper.Files)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/files/{uuid}", wrapper.DeleteFile)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/files/{uuid}", wrapper.ShareFile)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/refresh", wrapper.Refresh)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/sign-in", wrapper.SignIn)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/sign-up", wrapper.SignUp)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/users", wrapper.Users)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/users/available/{uuid}", wrapper.AvailableUsers)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/users/for-share/{uuid}", wrapper.UsersForShare)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/users/update-keys", wrapper.UpdateUserKeys)
	})

	return r
}
