// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: user.sql

package pgrepository

import (
	"context"

	"github.com/google/uuid"
)

const availableUsers = `-- name: AvailableUsers :many
SELECT uuid, password_hash, email, name, public_key, file_uuid, user_uuid, symmetric_key
FROM users
    JOIN file_crypto_keys ON users.uuid = file_crypto_keys.user_uuid
WHERE users.uuid != $1 AND file_crypto_keys.file_uuid = $2
`

type AvailableUsersParams struct {
	Uuid     uuid.UUID `json:"uuid"`
	FileUuid uuid.UUID `json:"file_uuid"`
}

type AvailableUsersRow struct {
	Uuid         uuid.UUID `json:"uuid"`
	PasswordHash string    `json:"password_hash"`
	Email        string    `json:"email"`
	Name         string    `json:"name"`
	PublicKey    []byte    `json:"public_key"`
	FileUuid     uuid.UUID `json:"file_uuid"`
	UserUuid     uuid.UUID `json:"user_uuid"`
	SymmetricKey string    `json:"symmetric_key"`
}

func (q *Queries) AvailableUsers(ctx context.Context, arg AvailableUsersParams) ([]AvailableUsersRow, error) {
	rows, err := q.db.Query(ctx, availableUsers, arg.Uuid, arg.FileUuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AvailableUsersRow
	for rows.Next() {
		var i AvailableUsersRow
		if err := rows.Scan(
			&i.Uuid,
			&i.PasswordHash,
			&i.Email,
			&i.Name,
			&i.PublicKey,
			&i.FileUuid,
			&i.UserUuid,
			&i.SymmetricKey,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (uuid, password_hash, email, name, public_key)
VALUES ($1, $2, $3, $4, $5)
RETURNING uuid, password_hash, email, name, public_key
`

type CreateUserParams struct {
	Uuid         uuid.UUID `json:"uuid"`
	PasswordHash string    `json:"password_hash"`
	Email        string    `json:"email"`
	Name         string    `json:"name"`
	PublicKey    []byte    `json:"public_key"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.Uuid,
		arg.PasswordHash,
		arg.Email,
		arg.Name,
		arg.PublicKey,
	)
	var i User
	err := row.Scan(
		&i.Uuid,
		&i.PasswordHash,
		&i.Email,
		&i.Name,
		&i.PublicKey,
	)
	return i, err
}

const user = `-- name: User :one
SELECT uuid, password_hash, email, name, public_key FROM users WHERE uuid = $1
`

type UserParams struct {
	Uuid uuid.UUID `json:"uuid"`
}

func (q *Queries) User(ctx context.Context, arg UserParams) (User, error) {
	row := q.db.QueryRow(ctx, user, arg.Uuid)
	var i User
	err := row.Scan(
		&i.Uuid,
		&i.PasswordHash,
		&i.Email,
		&i.Name,
		&i.PublicKey,
	)
	return i, err
}

const userByEmail = `-- name: UserByEmail :one
SELECT uuid, password_hash, email, name, public_key from users WHERE "email" = $1
`

type UserByEmailParams struct {
	Email string `json:"email"`
}

func (q *Queries) UserByEmail(ctx context.Context, arg UserByEmailParams) (User, error) {
	row := q.db.QueryRow(ctx, userByEmail, arg.Email)
	var i User
	err := row.Scan(
		&i.Uuid,
		&i.PasswordHash,
		&i.Email,
		&i.Name,
		&i.PublicKey,
	)
	return i, err
}

const users = `-- name: Users :many
SELECT uuid, password_hash, email, name, public_key FROM users WHERE uuid != $1
`

type UsersParams struct {
	Uuid uuid.UUID `json:"uuid"`
}

func (q *Queries) Users(ctx context.Context, arg UsersParams) ([]User, error) {
	rows, err := q.db.Query(ctx, users, arg.Uuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.Uuid,
			&i.PasswordHash,
			&i.Email,
			&i.Name,
			&i.PublicKey,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const usersForShare = `-- name: UsersForShare :many
SELECT users.uuid, users.password_hash, users.email, users.name, users.public_key
FROM users
    LEFT OUTER JOIN file_crypto_keys ON
    users.uuid = file_crypto_keys.user_uuid AND
    file_crypto_keys.file_uuid = $1
WHERE file_crypto_keys.user_uuid IS NULL
`

type UsersForShareParams struct {
	FileUuid uuid.UUID `json:"file_uuid"`
}

func (q *Queries) UsersForShare(ctx context.Context, arg UsersForShareParams) ([]User, error) {
	rows, err := q.db.Query(ctx, usersForShare, arg.FileUuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.Uuid,
			&i.PasswordHash,
			&i.Email,
			&i.Name,
			&i.PublicKey,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
