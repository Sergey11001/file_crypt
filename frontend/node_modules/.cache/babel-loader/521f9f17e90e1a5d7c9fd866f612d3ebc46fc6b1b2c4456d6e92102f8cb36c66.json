{"ast":null,"code":"import { decryptWithPrivateKey, decryptFile } from './crypto';\nimport filesApi from '../api/files';\nexport async function downloadAndDecryptFile(fileUuid, fileName, privateKeyPem) {\n  try {\n    // 1. Получаем данные с сервера\n    const response = await filesApi.downloadFile(fileUuid);\n    const {\n      file,\n      file_data: encryptedFileBase64\n    } = response;\n\n    // 2. Валидация данных\n    if (!encryptedFileBase64 || typeof encryptedFileBase64 !== 'string') {\n      throw new Error('Invalid file data received from server');\n    }\n\n    // 3. Конвертируем Base64 в ArrayBuffer (с обработкой ошибок)\n    let encryptedFileData;\n    try {\n      encryptedFileData = base64ToArrayBuffer(encryptedFileBase64);\n    } catch (error) {\n      throw new Error(`Failed to decode file data: ${error.message}`);\n    }\n\n    // 4. Проверяем, что данные получены\n    if (!encryptedFileData || encryptedFileData.byteLength === 0) {\n      throw new Error('Empty file data after decoding');\n    }\n\n    // 5. Расшифровываем ключ\n    const symmetricKey = await decryptWithPrivateKey(file.symmetric_key, privateKeyPem);\n\n    // 6. Расшифровываем файл\n    const decryptedData = await decryptFile(encryptedFileData, symmetricKey);\n\n    // 7. Создаем и скачиваем файл\n    const blob = new Blob([decryptedData], {\n      type: 'application/octet-stream'\n    });\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    a.href = url;\n    a.download = fileName || file.name;\n    document.body.appendChild(a);\n    a.click();\n\n    // Очистка\n    setTimeout(() => {\n      document.body.removeChild(a);\n      URL.revokeObjectURL(url);\n    }, 100);\n    return true;\n  } catch (error) {\n    console.error('Download error:', error);\n    throw error;\n  }\n}\nfunction base64ToArrayBuffer(base64) {\n  try {\n    const cleanedBase64 = base64.replace(/-/g, '+') // Заменяем URL-safe символы\n    .replace(/_/g, '/').replace(/\\s/g, ''); // Удаляем пробелы\n\n    const binaryString = atob(cleanedBase64);\n    const bytes = new Uint8Array(binaryString.length);\n    for (let i = 0; i < binaryString.length; i++) {\n      bytes[i] = binaryString.charCodeAt(i);\n    }\n    return bytes.buffer;\n  } catch (error) {\n    console.error('Base64 decoding failed:', error);\n    throw new Error('Invalid Base64 string');\n  }\n}","map":{"version":3,"names":["decryptWithPrivateKey","decryptFile","filesApi","downloadAndDecryptFile","fileUuid","fileName","privateKeyPem","response","downloadFile","file","file_data","encryptedFileBase64","Error","encryptedFileData","base64ToArrayBuffer","error","message","byteLength","symmetricKey","symmetric_key","decryptedData","blob","Blob","type","url","URL","createObjectURL","a","document","createElement","href","download","name","body","appendChild","click","setTimeout","removeChild","revokeObjectURL","console","base64","cleanedBase64","replace","binaryString","atob","bytes","Uint8Array","length","i","charCodeAt","buffer"],"sources":["/home/sergey/WebstormProjects/univer/filecrypt/src/utils/fileDownload.js"],"sourcesContent":["import { decryptWithPrivateKey, decryptFile } from './crypto';\nimport filesApi from '../api/files';\n\nexport async function downloadAndDecryptFile(fileUuid, fileName, privateKeyPem) {\n    try {\n        // 1. Получаем данные с сервера\n        const response = await filesApi.downloadFile(fileUuid);\n        const { file, file_data: encryptedFileBase64 } = response;\n\n        // 2. Валидация данных\n        if (!encryptedFileBase64 || typeof encryptedFileBase64 !== 'string') {\n            throw new Error('Invalid file data received from server');\n        }\n\n        // 3. Конвертируем Base64 в ArrayBuffer (с обработкой ошибок)\n        let encryptedFileData;\n        try {\n            encryptedFileData = base64ToArrayBuffer(encryptedFileBase64);\n        } catch (error) {\n            throw new Error(`Failed to decode file data: ${error.message}`);\n        }\n\n        // 4. Проверяем, что данные получены\n        if (!encryptedFileData || encryptedFileData.byteLength === 0) {\n            throw new Error('Empty file data after decoding');\n        }\n\n        // 5. Расшифровываем ключ\n        const symmetricKey = await decryptWithPrivateKey(\n            file.symmetric_key,\n            privateKeyPem\n        );\n\n        // 6. Расшифровываем файл\n        const decryptedData = await decryptFile(encryptedFileData, symmetricKey);\n\n        // 7. Создаем и скачиваем файл\n        const blob = new Blob([decryptedData], { type: 'application/octet-stream' });\n        const url = URL.createObjectURL(blob);\n        const a = document.createElement('a');\n        a.href = url;\n        a.download = fileName || file.name;\n        document.body.appendChild(a);\n        a.click();\n\n        // Очистка\n        setTimeout(() => {\n            document.body.removeChild(a);\n            URL.revokeObjectURL(url);\n        }, 100);\n\n        return true;\n    } catch (error) {\n        console.error('Download error:', error);\n        throw error;\n    }\n}\n\nfunction base64ToArrayBuffer(base64) {\n    try {\n        const cleanedBase64 = base64\n            .replace(/-/g, '+')  // Заменяем URL-safe символы\n            .replace(/_/g, '/')\n            .replace(/\\s/g, ''); // Удаляем пробелы\n\n        const binaryString = atob(cleanedBase64);\n\n        const bytes = new Uint8Array(binaryString.length);\n        for (let i = 0; i < binaryString.length; i++) {\n            bytes[i] = binaryString.charCodeAt(i);\n        }\n\n        return bytes.buffer;\n    } catch (error) {\n        console.error('Base64 decoding failed:', error);\n        throw new Error('Invalid Base64 string');\n    }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}